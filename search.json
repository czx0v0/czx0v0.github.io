[{"title":"python学习笔记📒｜第三章","url":"/2022/12/11/python-3/","content":"第三章 循环语句for 循环for i in range(5): # [0,5)    print(i)for i in range(5,9):    print(i)for i in range(0,10,3):# 步长3    print(i)for i in range(-10,-100,-30):    print(i)\nA 3,6,9 终点不能算在内！！for 遍历列表len():可以用来求列表的长度（元素个数），也可以求字符串长度break 语句的作用：跳出整个循环continue 跳到下次循环\nfor i in range(26):    print(chr(ord(&quot;a&quot;)+i),end=&quot;&quot;) #&gt;&gt;abcdefghijklmnopqrstuvwxyz\nord(x) 求字符x的编码chr(x) 求编码x的字符可以用8个连续的0或1（即一个字节）来表示一个字母，数字或标点符号\nfor 循环的简单例题加和因子多重循环 n*m次8:0 1 0 2 1 1 1 2 Q没有2？？（1，n）（i+1，n+1）第一个数比第二个小\nwhile 循环while x:    sentence1else:    sentence2\naaaaaaa最小公倍数：枚举!!while not(n%x &#x3D;&#x3D; 0 and n% y &#x3D;&#x3D;0 and n % z &#x3D;&#x3D;0)n&#x3D;m&#x3D;max(x,y,z)n+&#x3D;m()（没必要一个个试）\n异常处理如何判断循环结束try：except：\n\n不合适转换\n输入已经结束的inut\n除法的除数为0\n整数字符串相加\n列表的下标越界\n\nctrl + Z:告诉程序输入已经没了！ctrl + D:在pycharm里面告诉程序输入已经没了\n","categories":["自习室","python"],"tags":["python","学习笔记"]},{"title":"python学习笔记📒｜第四章","url":"/2022/12/14/python-4/","content":"1 函数的概念与用法函数的定义def function_name1(parameter1.parameter2):    sentencesdef function_name2():            # 也可以没有参数    sentences  \n函数的调用function_name1(parameter1.parameter2)\n也可以由函数内部return语句决定\nreturn return_value\n一个函数内部可以出现多条return语句，每个return语句返回值可以不同例1:\ndef Max(x,y):       # x,y形参    if x&gt;y:        return x    else:        return yn = Max(4,6)        # 实参print(n,Max(20,n))print(Max(&quot;about&quot;,&quot;take&quot;))\n\n6 20take\n\n例2:\ndef IsPrime(n):    if n&lt;=1 or n%2 == 0 and n!= 2:        return False    elif n==2:        return True    else:        for i in range(3,n,2):            if n % i ==0:                return False            if i*i &gt; n:                break    return Truefor i in range(100):    if(IsPrime(i)):        print(i,end=&quot; &quot;)\n\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n\n函数的返回值也可以有不返回值的函数和返回多个值（元组）的函数\n函数中的变量\n一个函数内部的变量在函数外部不能使用\n不同函数中的同名变量不会互相影响\n函数中的变量和全局变量同名的情况：\n如果没有对x进行赋值，函数内部的x是全局的x\n如果对x进行赋值且没有特别声明，则在函数中全局x不起作用，函数中的x就是函数内部起作用的x\n函数内部可以用global x声明x是全局的x\n\n\n\n2 递归递归一个概念的定义中用到了这个概念本身，这就叫递归\n用递归的方式定义n的阶乘1）“1的阶乘”是1\n2）“n的阶乘”是n乘以“（n-1）的阶乘”\n\n例1: 求n的阶乘\ndef Factorial(n):if n&lt;2:                             # 相当于终止条件    return 1else:    return n * Factorial(n-1)\n例2: 求斐波那契数列第n项\ndef Fib(n):    if n==1 or n==2:        return 1;    else:        return Fib(n-1)+Fib(n-2)\n\n递归例题：上台阶上台阶问题：有n级台阶，每步可以走一级或2级，问有多少种不同的走法\ndef ways(n):    if n == 1:        return 1    elif n == 2:        return 2    else:        return ways(n-1)+ways(n-2)    #第一步走一级的走法+第一步走二级的走法print(ways(4))\n(先走第一步）\n4 递归例题：汉诺塔def Hanoi(n,src,mid,dest):    if(n == 1):        print(src+&quot;-&gt;&quot;+dest)        return    Hanoi(n-1,src,dest,mid)    print(src+&quot;-&gt;&quot;+dest)    Hanoi(n-1,mid,src,dest)n = int(input())Hanoi(n,&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;)\n如果64个盘子，如果一秒1次移动，需要2^64-1次，世界毁灭也移不完手工解决汉诺塔问题：拆子问题\n","categories":["自习室","python"],"tags":["python","学习笔记"]},{"title":"python学习笔记📒|第五章","url":"/2022/12/16/python-5/","content":"1 python变量的指针本质python 的数据类型基本数据类型：int,float,complex组合数据类型：字符串     str元组        tuple     （无法改变值？）列表        list字典        dict集合        set\nisinstance函数isinstance(x,y) 查询数据x是否是y类型\nlen函数len函数可以用来求组合数据类型的元素个数\npython 中的变量都是指针python中所有可赋值的东西，即可以出现在赋值号“&#x3D;”左边的东西，都是指针指针即代表内存单元的地址。可以将指针理解成箭头。对变量进行赋值的本质：让变量箭头指向某个地方。x is y 表示x和y是否指向同一个地方。x &#x3D;&#x3D; y 表示x和y的内容是否相同。\na = [1,2,3,4]b = [1,2,3,4]print(a == b)print(a is b)c = aprint(c is a)a[2] = &quot;ok&quot;print(c)\n\nTrueFalseTrue[1, 2, ‘ok’, 4]\n\na和c指向同一个地方，所以修改a[2],c[2]也改变注意✨：\n\n对int，float，complex，str，tuple类型的变量a和b只需关注a &#x3D;&#x3D; b是否成立，关注 a is b 无意义，因为这些数据本身都不会更改，不会产生a指向的东西改变了b指向的东西也跟着变的情况。\n对 list，dict，set类型的变量a和b，a &#x3D;&#x3D; b 和a is b的结果都需要关注。因这些数据本身会改变，改别了a指向的内容，说不定，b指向的内容也变了。\n\n列表元素的指针本质列表的元素可以赋值，因此也是指针。a[0],b[0]等元素也是指针，指向1等数字。\n2 函数参数的传递函数参数传递的方式都是传值，即形参是实际参数的一个拷贝。函数参数也是指针。形参和实参指向同一个地方。对形参赋值（让其指向别处）不会影响实参，\ndef Swap(x,y):    tmp = x    x = y    y = tmpa = 4b = 5Swap(a,b)print(a,b)\n\n输出：4，5\n\nx和y是a，b的拷贝，改变a，b的拷贝的指向，没有改变a，b。如果执行过程中改变形参所指向的地方的内容，则改变实参。\ndef swap2(x,y):    tmp = x[0]    x[0] = y[0]         # 若x，y是列表，tmp，x[0],y[0]都是指针    y[0] = tmpa = [4,5]b = [6,7]swap2(a,b)              # 进入函数后，x和a指向相同的地方，y和b指向相同的地方print(a,b)\n\n[6, 5] [4, 7]\n\n3 字符串的转义字符‘&#39;及后面的某些字符会构成转义字符，即两个字符当成一个字符看\\n      换行\\t      制表&quot;      双引号\\      斜杠转义字符只能出现在字符串里面，必须用引号扩起来。\n不转义的字符串print(r&#39;ab\\ncd&#39;)r 表示字符串里面的\\就是\\，不和后面的字符合并起来看待。\n4 字符串的切片（子串）字符串的切片（也叫子串，即连续的一部分）a[x:y]表示字符串a里从下标x到下标y那一部分的子串（不包括下标y的那个字符）\na = &quot;ABCD&quot;print(a[1:2])print(a[0:-1])print(a[-3:-1])print(a[2:])print(a[:3])print(&quot;abcd&quot;[2:3])\n\nBABCBCCDABCc\n\na[x:y:z]表示从a[x]到a[y]（a[y]不算），每z个字符取一个，然后拼起来，为负数表示倒着取。x，y可以省略，x，y全省略表示从头取到尾或从尾取到头。字符串切片的写法也可以用于元组和列表\n5 字符串的分割（split）s.split(x)split函数可以带参数，上句表示用字符串x作分隔符分割字符串x，得到分割后的列表。两个相邻分割符之间会被分割出一个空串。\na = &quot;12..34.5346...a&quot;print(a.split(&quot;..&quot;))print(a.split(&quot;.&quot;))print(a.split(&quot;34&quot;))\n\n[‘12’, ‘34.5346’, ‘.a’][‘12’, ‘’, ‘34’, ‘5346’, ‘’, ‘’, ‘a’][‘12..’, ‘.5’, ‘6…a’]\n\n字符串高级分割多个分割串分割\nimport rea = &#x27;Beautiful, is; better*than\\nugly&#x27;print(re.split(&#x27;;| |,|\\*|\\n&#x27;,a))        # 分割串用｜隔开\n\n[‘Beautiful’, ‘’, ‘is’, ‘’, ‘better’, ‘than’, ‘ugly’]\n\n6 字符串的函数count 求子串出现次数s = &#x27;thisAAbb AA&#x27;s.count(&#x27;AA&#x27;)       # 2\nlen 字符串长度s = &#x27;1234&#x27;len(s)              # 4\nupper,lower 转大写，小写s.upper（）\nfind，rfind，index，rindex在字符串中查找子串，返回找到的位置（下标）。找不到的话，find返回-1，index引发异常\ns = &quot;1234abc567abc12&quot;print(s.find(&quot;ab&quot;))print(s.rfind(&quot;ab&quot;))        # rfind从末尾开始找，find从头开始找try:    s.index(&quot;afb&quot;)except Exception as e:    print(e)\n\n410substring not found\n\n find 还可以指定查找起点 s = &quot;1234abc567abc12&quot;print(s.find(&quot;12&quot;,4))\n\n13\n\nreplace替换其他\nisdigit(),islower(),isupper()判断字符串是否是数，是否全是小写等\nstartwith，endwith 判断字符串是否以某子串开头、结尾。\nstrip（s),lstrip(s),strip(s)返回除去两端、左端、右端 在s中出现的字符后的字符串\n\n7 字符串的格式化字符串的编码字符串的编码在内存中是unicode的，虽然写入文件时，可能是gbk或utf-8的\nord(a)      # &gt;&gt; 97chr(97)     # &gt;&gt; a\n字符串格式化x = &quot;Hello &#123;0&#125; &#123;1:10&#125;,you get $&#123;2:0.4f&#125;&quot;.format(&quot;Mr.&quot;,&quot;Jack&quot;,3.2)print(x)x = &quot;Hello &#123;0&#125; &#123;1:&gt;10&#125;,you get $&#123;2:0.4f&#125;&quot;.format(&quot;Mr.&quot;,&quot;Jack&quot;,3.2)print(x)\n\nHello Mr. Jack      ,you get $3.2000Hello Mr.       Jack,you get $3.2000\n\n{序号：宽度.精度 类型}           宽度可以是0\n&gt;: 右对齐&lt;: 左对齐^: 中对齐\n8 元组一个元组由数个逗号分隔的值组成，前后可加括号元组不能修改，即不可增删元素，不可对元素赋值，不可修改元素顺序\nt = 12345,54321,&#x27;hello&#x27;print(t[0])u = t,(1,2,3,4,5)print(u)print(u[0][1])\n\n12345((12345, 54321, ‘hello’), (1, 2, 3, 4, 5))54321\n\n元组的元素内容有可能被修改。例如：如果元素是列表，可以修改该列表\nv = (&quot;hello&quot;,[1,2,3],[3,2,1])# v[1] = 32v[1][0] = &#x27;world&#x27;print(v)print(len(v))\n\n(‘hello’, [‘world’, 2, 3], [3, 2, 1])3\n\n元组元素的指针本质元组的元素都是指针。元组元素不可修改，是指不可改变元素的指向，但是元组元素指向的内容是有可能被修改的。类似足球队的队员。\n用下标访问元组，以及元组切片用法和字符串一样。\n可以对元组进行连接组合tup1 = (12,34.56)tup2 = (&#x27;abc&#x27;,&#x27;xyz&#x27;)tup3 = tup1+tup2tup3 += (10,20)\n元组的运算和迭代x = (1,2,3)*3print(x)                #&gt;&gt;(1,2,3,1,2,3,1,2,3)print(3 in (1,2,3))     #&gt;&gt;truefor i in (1,2,3):    print(i,end =&quot;&quot;)    #&gt;&gt;123\n元组赋值x = (1,2,3)b = xprint(b is x)x += (100,)         # 等价于x = x+（100，）新建了一个元组。x与b不指向一个地方了！print(x)            # （1，2，3，100）print(b)            # （1，2，3）\n元组比大小\n两个元组比大小。就是逐个元素比大小，直到分出胜负\n如果有两个对应元素不可比大小，则输出runtime error\n\n练习题可以修改元组t和列表内容，不能修改t[0]a &#x3D;[1,2,3]b &#x3D; （a,a）b[0][1] &#x3D; 100都指向同一个地方，b[0][1]被修改了,a全都变了\n9 示例：万年历用元组（列表）取代复杂分支结构输入1-7，输出星期几\nweekdays = &quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,\\                &quot;Friday&quot;,&quot;Saturday&quot;,&quot;Sunday&quot;n = int(input())if n&gt;7 or n&lt;1:        print(&quot;Illegal&quot;)else:        print(weekdays[n-1])\n例题：已知2012年1月25日星期三，输出之后的一个日期的是星期几如：Input 2015 11 02 Output 1\n\n累加法monthDays =[-1,31,28,31,30,31,30,31,31,30,31,30,31]days = 0lst = input().split()year,month,date = int(lst[0]),int(lst[1]),int(lst[2])for y in range(2012,year):    if y%4 == 0 and y%100 != 0 or y%400 == 0:        days += 366    else:        days += 365if y%4 == 0 and y%100 != 0 or y%400 == 0:    monthDays[2] = 29for i in range(1,month):    days += monthDays[i]days += datedays -= 22print(days%7)\nQ\n\n10 习题字符串例题：大小写互换小写字母比大写字母大32end &#x3D; ‘’’’\n石头剪刀布def result(a,b):    if a == b:        return 0    if a ==5 and b ==0:        return 1    if a == 0 and b ==5:        return -1    if a&lt;b:        return 1    else:        return -1s = input().split()n,na,nb = int(s[0]),int(s[1]),int(s[2])sa = input().split()sb = input().split()winA = winB = 0ptrA = ptrB = 0for i in range(n):    r = result( int(sa[ptrA]),int(sb[ptrB]))    if r ==1:        winA +=1    elif r ==1:        winB +=1    ptrA = (ptrA + 1)%na    ptrB = (ptrB + 1)%nbif winA &gt; winB:    print(&quot;A&quot;)elif winB &gt; winA:    print(&quot;B&quot;)else:    print(&quot;draw&quot;)\n\n10 3 40 2 50 5 0 2A\n\n","categories":["自习室","python"],"tags":["python","学习笔记"]},{"title":"C语言学习笔记📒|第十七章","url":"/2022/12/16/%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/","content":"第十七章课程：王道c语言督学营\n17.1 上节课作业讲解如果上课的代码不能独立写出来。首先就根据老师的代码，来画图。然后再对照流程图来完成代码。通过for循环读取十个元素。\n17.2 与408关联选择排序、堆排序、归并排序\n17.3 选择排序原理及实战选择排序分为简单选择排序、堆排序。\n简单选择排序 selection-sort原理：假设排序表为L[1……n]，第i趟排序是从中选择关键字最小的元素与L[i]交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使整个排序表有序。用min记录最小值的坐标。\n\n3,87,2,93,78,56,61,38,12,40一趟选择排序后的结果：2,87,3,,93,78,56,61,38,12,40\n\n简单选择排序实战每次把最小的交换到前面。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;typedef int ElemType;typedef struct&#123;    ElemType *elem;    int Tablelen;&#125;SSTable;//顺序表void ST_Init(SSTable &amp;ST,int len)&#123;    ST.Tablelen=len;    ST.elem=(ElemType *)malloc(sizeof(ElemType)*ST.Tablelen);    int i;    srand(time(NULL));//随机树生成，每次执行代码得到随机十个元素    for(i=0;i&lt;ST.Tablelen;i++)    &#123;        ST.elem[i]=rand()%100;//生成的数0-99之间    &#125;&#125;void ST_print(SSTable ST)&#123;    for(int i=0;i&lt;ST.Tablelen;i++)    &#123;        printf(&quot;%3d&quot;,ST.elem[i]);    &#125;    printf(&quot;\\n&quot;);&#125;void swap(ElemType &amp;a,ElemType &amp;b)&#123;    ElemType tmp;    tmp = a;    a = b;    b = tmp;&#125;\nint main() &#123;    SSTable ST;    ST_Init(ST,10);    ST_print(ST);//    ElemType A[10]=&#123;69,47,99,25,92,72,69,14,10,94&#125;;//    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcpy，不能用strcpy，初试考memcpy概率很低//    memcpy(ST.elem,A,sizeof(A));//为了降低调试难度，每组数组数据固定而设计    SelectSort(ST.elem,10);    ST_print(ST);    return 0;&#125;\nvoid SelectSort(ElemType *A,int n)&#123;    int i,j,min;//min记录最小值元素的下标    for(i=0;i&lt;n-1;i++)    &#123;        min = i;//我们认为0号元素最小        for (j=i+1;j&lt;n;j++)//找到从i开始到最后的序列的最小值的下标        &#123;//(j不是每一次都固定的)            if (A[j]&lt;A[min])//当某个元素A[j]小于了最小元素            &#123;                min = j;//就把下标j赋值给min，min就记录下来了最小值的下标            &#125;        &#125;        //循环的外面        if(min != i)//其实自己与自己交换也没关系        &#123;            swap(A[i],A[min]);        &#125;    &#125;&#125;\n选择排序的时间复杂度：O（n^2)选择排序的空间复杂度：O(1)（未使用额外的空间）\n17.4 堆排序原理解析堆堆（Heap）是计算机科学中一种特殊的树状数据结构。\n\n若满足以下特性，可以称为堆：Q？一定最大最小哪吗？“给定堆中任意节点P和C，若P是C的父节点，则P的值恒小于等于（或大于等于）C的值。”最小堆（min heap）：父节点的值恒小于子节点的值。（小根堆，小顶堆）最大堆（max heap）：父节点的值恒大于子节点的值。（大根堆，大顶堆）根节点（root）：堆中最顶端的那个节点。\n\n假设把3,87,2,93,78,56,61,38,12,40这10个元素采用层次建树法建成一棵完全二叉树。如果能将二叉树中的每一个元素对应到数组下标的这种数据结构称为堆，比如最后一个父元素的下标是N&#x2F;2-1，也就是a[4]，对应的值为87。N&#x2F;2-1？：这是层次建立一棵完全二叉树的特性。如果父节点的下标是dad，那么父节点对应的左子节点的下标值是2*dad+1。\n我们可以依次将每颗子树都调整为父节点最大，最终将整颗子树变为一个大根堆。\n\n学编程要按部就班，要理解了，不要跳跃，不要急躁。\n\n动画地址:(https://www.cs.usfca.edu/~galles/visualization/HeapSort.html)\n17.5 堆排序实战建议：一些前置步骤可以不手写。增量编写。第一次写先不用随机的元素。\nvoid AdjustDown1(ElemType A[],int k,int len)&#123;    int dad = k;//父亲的下标    int son = 2*dad+1;//左孩子的下标    while(son&lt;len)    &#123;//son+1也要小于len        if(son+1&lt;len&amp;&amp;A[son]&lt;A[son+1])//如果左孩子小于右孩子        &#123;            son++;//拿右孩子        &#125;        if(A[son]&gt;A[dad])        &#123;            swap(A[son],A[dad]);//如果孩子大于父亲就交换            dad = son;//发生变动后son重新作为dad，去判断下面的子树是否符合大根堆            son = 2*dad+1;        &#125;else&#123;            break;        &#125;    &#125;&#125;\nvoid HeapSort1(ElemType A[],int len)&#123;    int i;    //第一步就是把堆调整为大根堆    for(i =len/2-1;i&gt;=0;i--)//i代表的是剩余的无序数组的长度    &#123;        AdjustDown1(A,i,len);//10？9？    &#125;    //交换根部元素和最后一个元素    swap(A[0],A[len-1]);//传10要-1。传9不用-1。    for(i =len-1;i&gt;1;i--)//i最小为2，i代表的是剩余的无序数组的长度    &#123;        AdjustDown1(A,0,i);//调整剩余元素变为大根域        swap(A[0],A[i-1]);//交换根部元素和最后一个元素    &#125;&#125;\n\n  3 87  2 93 78 56 61 38 12 40  2  3 12 38 40 56 61 78 87 93\n\n  （王道书上，从1开始，左孩子是dad2倍）  AdjustDown1最多执行次数(树的高度)\\log_2 n.  堆排序的时间复杂度：O(n\\log_2 n)  堆排序的空间复杂度：O(1)\n17.6 归并排序原理及实战归并排序的原理解析把两个元素归为一组，小组内排序。然后再把两个有序小组合并为一个有序小组，不断进行，最终合并为一个有序数组。动画地址：(https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html归并排序是递归的。首先：最小下标low与最大下标high相加除以2，得到中间下标mid。\n归并排序实战#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 7typedef int ElemType;//不限制两两归并还是三三归并，但考研考的是两两归并void Merge(ElemType A[],int low,int mid,int high)&#123;//业界全部使用额外空间，空间复杂度O(n)    static ElemType B[N];//加static的目的是无论递归调用多少次，都只有一个B[N]    int i,j,k;    for(i = low;i &lt;= high;i++)//把A[i]里的元素都给B[i]    &#123;        B[i] = A[i];    &#125;    for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;)//合并两个有序数组    &#123;        if(B[i]&lt;B[j])        &#123;            A[k] = B[i];            i++;            k++;        &#125;else&#123;            A[k] = B[j];            j++;            k++;        &#125;    &#125;    //在循环外，把某一个数组中剩余的元素放进来    while(i&lt;=mid)//前一半有剩余的放入    &#123;        A[k] = B[i];        i++;        k++;    &#125;    while(j&lt;=high)//后一半有剩余的放入    &#123;        A[k] = B[j];        j++;        k++;//这三行等价于A[k++]=B[j++];    &#125;&#125;void MergeSort(ElemType A[],int low,int high)&#123;    if(low&lt;high)    &#123;        int mid =(low+high)/2;        MergeSort(A,low,mid);        MergeSort(A,mid+1,high);        Merge(A,low,mid,high);    &#125;&#125;void print(int *a)&#123;    for(int i =0;i&lt;N;i++)    &#123;        printf(&quot;%3d&quot;,a[i]);    &#125;    printf(&quot;\\n&quot;);&#125;int main() &#123;    int A[N] = &#123;49,30,65,97,76,13,27&#125;;    MergeSort(A,0,6);    print(A);    return 0;&#125;\n归并排序时间复杂度：O(n\\log_2 n)归并排序空间复杂度：O(n)\n所有排序时间复杂度与空间复杂度汇总稳定性是指排序前后，相等的元素位置是否会被交换。复杂性是指代码编写的难度。\n","categories":["自习室","C/C++"],"tags":["学习笔记","C++","C语言"]}]